{"version":3,"mappings":"uBAAAA,2DCgBA,MAAMC,EAAwB,WAC9B,IAAKC,EAIJ,MAJD,OAAKA,QAAe,KAClBA,gBACAA,kBACAA,YAHGA,EAAL,IAAKA,GAIJ,GAmBK,WAAgCC,EAASC,GAC7CC,YAAY,CACVF,QACCF,GAAwBG,IAwB7B,WAA0BE,EAAUF,GAClC,OAAOH,KAAyBK,GAAOA,EAAIL,KAA2BG,EAuBxE,MAAMG,EAAsB,OACfC,EAAwB,kBAmB/B,WAAiCC,GACrC,OAZI,WAA6BC,EAAYD,GAC7CE,KAAKC,cACH,IAAIC,YAAqCL,EAAuB,CAC9DM,OAAQ,CACNJ,KACAP,KAAMM,MAOLM,CAAmBR,EAAqBE,GAGjD,QAGEO,YAA6BC,mBAFrBC,uBAA8BC,EAI/BC,cAAcjB,MACdkB,WAAQlB,EAAMe,KAAKI,gBACtBJ,KAAKI,aAAenB,EACpBe,KAAKD,SAASd,KAuDd,QAUJa,YACmBO,EACjBC,EACiBC,GAAc,GAFdP,0BAEAA,mBAZXA,oBAA6C,GAE7CA,sBAA0D,GAE1DA,sBACN,GAEMA,wBAAoB,KAO1BQ,SAAMF,GAAgBG,QAAQ,IAC5BT,KAAKU,eAAeC,KAAKN,MAIrBO,UACN,OAAOZ,KAAKa,iBAAiBC,OAAS,EAGhCC,oBACN,OAAOf,KAAKU,eAAeI,OAAS,EAG9BE,iBACFhB,KAAKiB,oBAITC,WAAW,IAAMlB,KAAKmB,YAAa,GACnCnB,KAAKiB,mBAAoB,GAGnBE,YACNnB,KAAKoB,MACH,YACApB,KAAKa,iBAAiBC,OACtBd,KAAKU,eAAeI,QAGtBd,KAAKiB,mBAAoB,GACzBT,WACEa,KAAKC,IAAItB,KAAKa,iBAAiBC,OAAQd,KAAKU,eAAeI,SAC3DL,QAAQ,KAKR,IAJKT,KAAKY,YAILZ,KAAKe,oBACR,OAGF,MAAMQ,EAAavB,KAAKwB,eAClBC,EAAYzB,KAAKU,eAAegB,MAEtC1B,KAAK2B,cAAcJ,EAAYE,GAG/BzB,KAAKoB,MAAM,gBAAiBG,EAAW/B,GAAI+B,EAAWK,KAAKC,cAC3DJ,EACGK,QAAQP,EAAWK,KAAML,EAAWQ,UACpCC,KAAM/C,IACLe,KAAKoB,MACH,cACAG,EAAW/B,GACX+B,EAAWK,KAAKC,cAEXN,EAAWU,OAAOhD,KAE1BiD,MAAOC,IACNnC,KAAKoB,MAAM,cAAee,EAAOZ,EAAWK,KAAKC,cACjDN,EAAWa,QAAQD,KAGpBE,QAAQ,KACPrC,KAAKoB,MACH,gBACAG,EAAW/B,GACX+B,EAAWK,KAAKC,cAElB7B,KAAKsC,KAAKf,EAAW/B,IAErBQ,KAAKgB,qBAKLI,SAASmB,GACXvC,KAAKO,aACPiC,QAAQpB,SAASmB,GAIbZ,cACNJ,EACAE,GAEAzB,KAAKoB,MAAM,gBAAiBG,EAAW/B,GAAI+B,EAAWK,KAAKC,cAC3D7B,KAAKyC,iBAAiB9B,KAAK,CACzBY,aACAE,cAWGa,KACL9C,EACAkD,EAAsE,UAGtE1C,KAAKoB,MAAM,OAAQ5B,GACnBQ,KAAK2C,QAAQnD,GAEb,MAAMoD,EAAiB5C,KAAK6C,sBAAsBrD,GAC9CoD,IACF5C,KAAKoB,MAAM,sBACXwB,EAAenB,UAAUa,OACzBI,EAAuBE,GACvB5C,KAAKoB,MAAM,uBACXpB,KAAKU,eAAeC,KAAKiC,EAAenB,YAIrCqB,QACLlB,GAEA,MAAMmB,EAAS,IAAIC,IACbC,EAAe,IAAIC,EAAmBC,GAC1CJ,EAAOK,KAAKD,IAER3D,EAAK,GACTQ,KAAKa,iBAAiBC,WACpB,IAAIuC,MAAOC,aAAajC,KAAKkC,MAAsB,IAAhBlC,KAAKmC,YACtClB,EAAO,KACXtC,KAAKoB,MAAM,mBAAoB5B,GAC/BQ,KAAKsC,KAAK9C,IAGZQ,KAAKoB,MAAM,UAAW5B,EAAIoC,EAAKC,cAE/B,MAAM5C,EAAO,IAAIwE,QAAgB,CAACxB,EAAQG,KACxCpC,KAAKa,iBAAiBF,KAAK,CACzBnB,KACAoC,OACAU,OACAL,SACAG,UACAL,SAAWoB,GAAYF,EAAa/C,cAAciD,KAEpDnD,KAAKoB,MACH,mBACA5B,EACAoC,EAAKC,aACL7B,KAAKa,iBAAiBC,UAI1B,YAAKE,iBAEE,CACLxB,KACAP,OACA8D,SACAT,QAIGd,eACLxB,KAAKoB,MAAM,gBACX,MAAMsC,EAAY1D,KAAKa,iBAAiB8C,MAAM,EAAG,GAAGjC,MACpD,GAAIgC,EACF,OAAO1D,KAAK2C,QAAQe,EAAUlE,IAM3BmD,QAAQnD,GACbQ,KAAKoB,MAAM,UAAW5B,GACtB,MAAMoE,EAAY5D,KAAKa,iBAAiBgD,UAAWC,GAASA,EAAKtE,KAAOA,GACxE,GAAIoE,GAAY,EACd,OAAO5D,KAAKa,iBAAiBkD,OAAOH,EAAW,GAAGlC,MAK9CmB,sBAAsBrD,GAC5BQ,KAAKoB,MAAM,wBAAyB5B,GACpC,MAAMwE,EAAQhE,KAAKyC,iBAAiBoB,UACjCC,GAASA,EAAKvC,WAAW/B,KAAOA,GAEnC,GAAIwE,GAAQ,EACV,OAAOhE,KAAKyC,iBAAiBsB,OAAOC,EAAO,GAAGtC,MAK3CuC,UACLjE,KAAKa,iBAAiBJ,QAASqD,GAASA,EAAKxB,QAC7CtC,KAAKyC,iBAAiBhC,QAASqD,GAASA,EAAKvC,WAAWe,SAI5D,IAAiB4B,WAAc,KA2ChBA,mBAAb,QAGEpE,YAAoCqE,0BAE1BC,YACR,OAAKpE,KAAKqE,SACRrE,KAAKqE,OAASrE,KAAKmE,mBAGdnE,KAAKqE,OAGPvC,QACLF,EACAG,GAEA,MAAMsC,EAASrE,KAAKoE,YAEdE,EAAS,IAAIb,QAAgB,CAACc,EAAKC,KACvCH,EAAOI,UAAY,EAAGxF,YA3XxB,WAA0BG,GAC9B,OAAOsF,EAAiBtF,EAAKJ,EAAgB2F,QA2XjCC,CAAgB3F,GAhYxB,WAA0BG,GAC9B,OAAOsF,EAAiBtF,EAAKJ,EAAgB6F,QAiY1BC,CAAgB7F,IACzB8C,EAAS9C,EAAKA,KAAKA,MAFnBsF,EAAItF,EAAKA,OAKboF,EAAOU,QAAUP,EACjBH,EAAOW,eAAiBR,IACvBnC,QAAQ,KACTgC,EAAOI,UAAY,OACnBJ,EAAOU,QAAU,OACjBV,EAAOW,eAAiB,SAG1BX,SAAOlF,YA1Zb,WAAuB0C,EAAsBoD,GAC3C,MAAO,EACJlG,GAAwBC,EAAgBkG,IACzCrD,eACAoD,QAsZqBE,CAAcvD,EAAKC,aAAcD,EAAKqD,OAElDX,EAGFhC,aACM,QAAX8C,OAAKf,cAAMgB,SAAEC,YACbtF,KAAKqE,YAASpE,IAILiE,iBAAb,QACepC,QACXF,EACAG,GAAkC,0BAElC,MAAMwD,EAAkBxC,IACtBhB,EAASgB,EAAOnD,OAAOX,OAEzBQ,KAAK+F,iBAAiBlG,EAAuBiG,GAE7C,MAAMjB,QAAe1C,EAAK6D,YAAY7D,EAAKqD,MAE3CxF,YAAKiG,oBAAoBpG,EAAuBiG,GAEzCjB,GAX2B,GAc7BhC,UC5eJ,MAAMqD,EAA+B,IAC1C,IAAIC,OAAOC,SAAIC,IAAID,oBCDRE,EAA4B,IACvC,IAAIH,OAAOC,SAAIC,IAAID,oBCYfG,EAA0B,IAAM,IAAI9B,iBAEpC+B,EAA8B,IAClC,IAAI/B,qBAAkCyB,GAElCO,EAA4B,IAChC,IAAIhC,qBAAkC6B,GAoBlC,QAeJjG,YACmBqG,EACAC,GAAc,GADdpG,oBACAA,mBAVFA,mBAAgC,CAC/CqG,QAAS,EACTC,OAAQ,EACRC,MAAO,KAGOvG,YAAS,IAAIgD,IAM3BhD,KAAKwG,eAAiB,IAAItC,EArC9B,WACEiC,EACAM,GAEA,OAAKN,EAAaO,UAIdD,EACKP,EAGFD,EAPED,EAiCLW,CAAsBR,GAAc,GACpCA,EAAaO,UAAYP,EAAaS,YAAc,GAGtD5G,KAAK6G,4BHwcH,WACJC,EACAC,GAEA,OAAO,IAAIC,MAAMD,EAAc,CAC7BE,KAAIC,EAAaC,IACR,IAAIlC,IACF6B,EAAShE,QAAQ,CACtBmC,OACApD,aAAcsF,EAAKC,WACnB3B,SAAWsB,EAAqBI,OGldHE,CACjCrH,KAAKwG,eACLc,MAGFtH,KAAKuH,oBAAsD,EAAhCvH,KAAKmG,aAAaS,YAGvCxF,SAAS6D,GACXjF,KAAKoG,aACP5D,QAAQpB,SAAS6D,GAIbuC,gBAAgBC,GACtBzH,KAAK0H,cAAcpB,QAAUmB,EAC7BzH,KAAK+C,OAAOK,KAAIuE,iBACX3H,KAAK0H,gBAIJE,kBAAkBH,GACxBzH,KAAK0H,cAAcrB,SAAWoB,EAC9BzH,KAAK+C,OAAOK,KAAIuE,iBACX3H,KAAK0H,gBAIJG,2BAA8BX,EAAWY,GAC/C,OAAIC,MAAMC,QAAQd,GACZA,EAAO,aAAczD,QAChByD,EAAOe,IAAKnE,GACjB9D,KAAK6H,2BAA2B/D,EAAMgE,KAGxC9H,KAAK4H,kBAAkBE,EAAYZ,EAAOpG,QACnCoG,GAEAA,aAAkBzD,QACpByD,EAAO7E,QAAQ,IACpBrC,KAAK4H,kBAAkBE,KAGzB9H,KAAK4H,kBAAkBE,GAChBZ,GAaHgB,gBAAmBhB,EAAWiB,GAEpC,OADAnI,KAAKwH,gBAA+B,IAAfW,GACjBJ,MAAMC,QAAQd,GACTlH,KAAK6H,2BACVX,EACC,EAAIA,EAAOpG,OAAUqH,EAAe,KAGhCnI,KAAK6H,2BAA2BX,EAAuB,IAAfiB,GAItCC,UACXC,GAA6C,qCAI7C,GAFAC,EAAKZ,cAAcrB,QAAU,EAG3BgC,EAAgBE,MAAMzH,OAAS,GACO,IAAtCuH,EAAgBG,WAAW1H,QAC3BuH,EAAgBI,SAAWJ,EAAgBK,SAE3C,MAAO,GAGTJ,EAAKV,kBAAkB,GAEvB,MAAMe,GAAY,IAAItF,MAAOC,UAC7B,IAAIsF,GAAQ,IAAIvF,MAAOC,UAGvB,MAAOuF,EAAyBC,GAC9BR,EAAKJ,gBACHZ,qCAAsDe,GACtD,KAEJC,EAAKlH,MACH,gBACA,IAAIiC,MAAOC,UAAYsF,EACvB,KACAC,EAAwB/H,QAG1B8H,GAAQ,IAAIvF,MAAOC,UACnB,MAAMyF,QAAsBtF,QAAQuF,IAClCV,EAAKJ,iBACHe,WAAMJ,EAAyB,KAAKZ,IACjC1F,GACC+F,EAAKzB,4BAA4BqC,0CAC/Bb,EACA9F,EACAuG,GACA7J,MAEN,KAGJqJ,EAAKlH,MACH,mBACA,IAAIiC,MAAOC,UAAYsF,EACvB,KACAG,EAAcjI,QAIhB8H,GAAQ,IAAIvF,MAAOC,UACnB,MAAM6F,EAAeb,EAAKJ,gBACxBZ,iCAAkDyB,GAClD,KAEF,SAAK3H,MACH,kBACA,IAAIiC,MAAOC,UAAYsF,EACvB,KACAO,EAAarI,QAEfwH,EAAKlH,MAAM,YAAY,IAAIiC,MAAOC,UAAYqF,EAAW,MAGzDL,EAAKV,kBACHU,EAAKZ,cAAcnB,MAAQ+B,EAAKZ,cAAcrB,SAGzC8C,GAtEsC,GAyExC7G,OACLtC,KAAKwG,eAAevC,gCAMA,QAApBmF,IAAcC,cAAMhE,SAAE/C,OACF,QAApBgG,IAAce,cAAMC,SAAEvG,OAAOwG,+BAI7BpD,EACAkC,GAA6C,0BAE7C,GAAMmB,EAAcH,OAClB,MAAM,IAAII,MACR,8DAIJ,MAAMJ,EAAS,IAAIG,EAAcrD,GACjCkD,EAAOtG,OAAO2G,UAAUC,GACxBH,EAAcH,OAAS,IAAIG,EAAcrD,GAEzC,MAAM7B,QAAe+E,EAAOjB,UAAUC,GACtCmB,SAAcH,YAASpJ,EAChBqE,GAdsC,KHhG3C,WAAiBsF,GACrB,MAAM3G,EAAe,IAAIC,EACtB2G,GAnFC,WAA+B5K,GACnC6K,EAAmB7K,EAAMD,EAAgB6F,QAkFCkF,CAAkBF,EAAUjK,SAEtEH,KAAK+F,iBAAiBlG,EAAwB0K,IAC1BA,EACJpK,OAAOJ,KAAOH,GAC1B4D,EAAa/C,cAFG8J,KAMpBvK,KAAK+F,iBACH,UADF,yBAEE,UAAOrC,GACL,MAAQlE,QAASkE,EACjB,IAhEN,WAAsB/D,EAAUwK,GAC9B,OACElF,EAAiBtF,EAAKJ,EAAgBkG,MArDf,iBAsDD9F,GArDC,SAsDDA,GACM,iBAArBA,EAAIyC,cACXkG,MAAMC,QAAQ5I,EAAI6F,OAClB7F,EAAIyC,gBAAgB+H,GACsB,mBAAnCA,EAAaxK,EAAIyC,cAwDlBoI,CAAahL,EAAM2K,GAGhB,CACL,MAAMM,EAAwBvC,OAAOwC,YACnCxC,OAAOyC,QAAQR,GAAc3B,IAAI,EAAEoC,EAAKC,KAAW,CACjDD,SACOC,KAGX,MAAM,IAAIb,MACR,WAAWzK,EAAgBkG,eAAeqF,KAAKC,UAC7CvL,EACA,KACA,gCAC6BsL,KAAKC,UAClCN,EACA,KACA,OA9GN,WAA+BjL,GACnC6K,EAAmB7K,EAAMD,EAAgB2F,QA6FnC8F,OADqBb,EAAa3K,EAAK4C,iBAAiB5C,EAAKgG,SALnE,uDIxIFyF,CD+OwC,CACtCtC,UAAWoB,EAAcpB,cElP3BuC,KAGA,cAEA,WACA,cACA,iBAGA,YACAnL,KACAoL,UACAC,YAIA,0CAGAhF,YAGAA,UAIAiF,MAGAA,SAGA,kCACA,eNnCAhM,KACAgM,gBACA,OAOA,IADAC,MACA,QAAiBC,WAAqBA,KAGtC,QAFAnF,YACAoF,KACAC,IAAkBA,WAAqBA,MACvC,oDACArF,iBAEAoF,KACAE,YAGA,MACArM,gBACA,eACA,cAGA,SAvBAqM,OACA,mBAA+BH,iBAAwCA,gBACvElM,cOJAgM,QACA,sBACA,cACA,MACA,cAAiCM,IACjCA,GCLAN,YACA,eACAA,qBACAnD,2BAAyC0D,0BCJzCP,OAGAA,OACArH,4CACAqH,YACAM,GACE,KCNFN,OAEAhM,OAA8B,qEAA0EA,SCFxGgM,iBCDAA,qDCAAA,UACAhM,WACAA,4BACAA,SCHA,MACAgM,eAEA,QACAhM,GACAwM,sBAEA,8DACAxM,mDAGAA,OCXAgM,kCCAAA,aCAAA,qBAIA,OACA,OAgBAA,cAEAhM,MAEAyM,iCAKA,oDACAC,iBACA3F,OAvBAsF,IACA,aACA,eACAL,WACAA,aAIA,IADAG,QACAD,UACAlM,aACA0M,gBCnBA,UACAV,QACAA,oBCDAA","names":["r","MESSAGE_TYPE_PROPERTY","MessageTypeEnum","data","type","postMessage","obj","PROGRESS_ROOT_EVENT","PROGRESS_STATUS_EVENT","progressStatus","id","self","dispatchEvent","CustomEvent","detail","emitProgressStatus","constructor","callback","this","undefined","maybeCallWith","isEqual","previousData","processorGenerator","processorCount","isDebugging","range","forEach","idleProcessors","push","hasWork","pendingWorkQueue","length","hasIdleProcessors","queueStartWork","isStartWorkQueued","setTimeout","startWork","debug","Math","min","queuedWork","dequeueFirst","processor","pop","onWorkStarted","work","functionName","execute","onStatus","then","onData","catch","error","onError","finally","stop","arr","console","runningWorkQueue","beforeProcessorRecycle","dequeue","workInProgress","dequeueWorkInProgress","enqueue","status","Subject","dedupeStatus","DeDuplicateCaller","message","next","Date","getTime","floor","random","Promise","firstItem","slice","itemIndex","findIndex","item","splice","index","stopAll","PooledExecutor","workerGenerator","getWorker","worker","result","res","rej","onmessage","isGenericMessage","RESULT","isResultMessage","STATUS","isStatusMessage","onerror","onmessageerror","args","RUN","newRunMessage","u","_a","terminate","dispatchStatus","addEventListener","function","removeEventListener","solverCalculateWorkerFactory","Worker","o","URL","solverCommonWorkerFactory","localProcessorGenerator","calculateProcessorGenerator","commonsProcessorGenerator","solverConfig","shouldDebug","current","buffer","total","pooledExecutor","useCommons","useWorker","getProcessorGenerator","workerCount","pooledCommonWorkerFunctions","executor","sourceObject","Proxy","get","target","prop","toString","pooledFunctions","commonWorkerFunctions","arraySplitGroupSize","incrementBuffer","count","currentStatus","Object","incrementProgress","monitorProgressIncrementor","increment","Array","isArray","map","monitorProgress","ratioOfTotal","calculate","calculateConfig","t","faces","operations","maxTotal","minTotal","fullStart","start","facePairingPermutations","operationPermutations","sortedResults","all","chunk","calculateFromFaceAndOperationPermutations","finalResults","e","solver","_b","unsubscribe","MugginsSolver","Error","subscribe","emitProgressStatusRoot","exposeObject","eventData","postGenericMessage","postStatusMessage","event","isRunMessage","exposeObjectStructure","fromEntries","entries","key","value","JSON","stringify","postResultMessage","expose","R","loaded","exports","n","m","c","k","l","d","a","enumerable","createScriptURL","importScripts","p"],"sources":["webpack/runtime/chunk loaded","./src/app/solver/worker-utils.ts","./src/app/solver/solver-calculate-worker-factory.ts","./src/app/solver/solver-common-worker-factory.ts","./src/app/solver/solver.ts","./src/app/solver/solver-calculate.worker.ts","webpack/bootstrap","webpack/runtime/compat get default export","webpack/runtime/define property getters","webpack/runtime/ensure chunk","webpack/runtime/get javascript chunk filename","webpack/runtime/get mini-css chunk filename","webpack/runtime/hasOwnProperty shorthand","webpack/runtime/node module decorator","webpack/runtime/trusted types policy","webpack/runtime/trusted types script url","webpack/runtime/publicPath","webpack/runtime/importScripts chunk loading","webpack/runtime/startup chunk dependencies","webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","/*\nA suite of utilities to make working with web workers easier.\n */\n\nimport { isEqual, range } from 'lodash';\nimport { Subject } from 'rxjs';\n\ntype JustMethodKeys<T> = {\n  [P in keyof T]: T[P] extends Function ? P : never;\n}[keyof T];\ntype ArgumentTypes<T> = T extends (...args: infer U) => any ? U : never;\n\ninterface ObjectFunctionCallMessage {\n  data: RunMessage;\n}\n\nconst MESSAGE_TYPE_PROPERTY = '__type__';\nenum MessageTypeEnum {\n  STATUS = 'status',\n  RESULT = 'result',\n  RUN = 'run',\n}\n\nexport interface StatusMessage {\n  [MESSAGE_TYPE_PROPERTY]: MessageTypeEnum.STATUS;\n  data: any;\n}\n\nconst PROP_FUNCTION_NAME = 'functionName';\nconst PROP_FUNCTION_ARGS = 'args';\ninterface RunMessage {\n  [MESSAGE_TYPE_PROPERTY]: MessageTypeEnum.RUN;\n  [PROP_FUNCTION_NAME]: string;\n  [PROP_FUNCTION_ARGS]: any[];\n}\n\ninterface GenericObject {\n  [key: string | symbol]: (...any: any[]) => any | never;\n}\n\nexport function postGenericMessage<T>(data: T, type: MessageTypeEnum): void {\n  postMessage({\n    data,\n    [MESSAGE_TYPE_PROPERTY]: type,\n  });\n}\n\nexport function postStatusMessage<T>(data: T): void {\n  postGenericMessage(data, MessageTypeEnum.STATUS);\n}\n\nexport function postResultMessage<T>(data: T): void {\n  postGenericMessage(data, MessageTypeEnum.RESULT);\n}\n\nexport function postErrorMessage<T>(data: T): void {\n  postGenericMessage(data, MessageTypeEnum.RESULT);\n}\n\nfunction newRunMessage(functionName: string, args: any[]): RunMessage {\n  return {\n    [MESSAGE_TYPE_PROPERTY]: MessageTypeEnum.RUN,\n    functionName,\n    args,\n  };\n}\n\nfunction isGenericMessage(obj: any, type: MessageTypeEnum): boolean {\n  return MESSAGE_TYPE_PROPERTY in obj && obj[MESSAGE_TYPE_PROPERTY] === type;\n}\n\nexport function isStatusMessage(obj: any): boolean {\n  return isGenericMessage(obj, MessageTypeEnum.STATUS);\n}\n\nexport function isResultMessage(obj: any): boolean {\n  return isGenericMessage(obj, MessageTypeEnum.RESULT);\n}\n\nfunction isRunMessage(obj: any, exposeObject: GenericObject): boolean {\n  return (\n    isGenericMessage(obj, MessageTypeEnum.RUN) &&\n    PROP_FUNCTION_NAME in obj &&\n    PROP_FUNCTION_ARGS in obj &&\n    typeof obj.functionName === 'string' &&\n    Array.isArray(obj.args) &&\n    obj.functionName in exposeObject &&\n    typeof exposeObject[obj.functionName] === 'function'\n  );\n}\n\nconst PROGRESS_ROOT_EVENT = 'root';\nexport const PROGRESS_STATUS_EVENT = 'progress_status';\nexport interface ProgressStatusEventData {\n  readonly detail: {\n    readonly id: string;\n    readonly data: ProgressStatus;\n  };\n}\n\nexport function emitProgressStatus(id: string, progressStatus: ProgressStatus) {\n  self.dispatchEvent(\n    new CustomEvent<ProgressStatusEventData>(PROGRESS_STATUS_EVENT, {\n      detail: {\n        id,\n        data: progressStatus,\n      },\n    } as any)\n  );\n}\n\nexport function emitProgressStatusRoot(progressStatus: ProgressStatus) {\n  return emitProgressStatus(PROGRESS_ROOT_EVENT, progressStatus);\n}\n\nclass DeDuplicateCaller<T> {\n  private previousData: T | undefined = undefined;\n\n  constructor(private readonly callback: (data: T) => void) {}\n\n  public maybeCallWith(data: T) {\n    if (!isEqual(data, this.previousData)) {\n      this.previousData = data;\n      this.callback(data);\n    }\n  }\n}\n\nexport function expose(exposeObject: GenericObject): void {\n  const dedupeStatus = new DeDuplicateCaller(\n    (eventData: ProgressStatusEventData) => postStatusMessage(eventData.detail)\n  );\n  self.addEventListener(PROGRESS_STATUS_EVENT, (event: Event) => {\n    const eventData = event as any as ProgressStatusEventData;\n    if (eventData.detail.id === PROGRESS_ROOT_EVENT) {\n      dedupeStatus.maybeCallWith(eventData);\n    }\n  });\n\n  self.addEventListener(\n    'message',\n    async (message: ObjectFunctionCallMessage) => {\n      const { data } = message;\n      if (isRunMessage(data, exposeObject)) {\n        const result = await exposeObject[data.functionName](...data.args);\n        postResultMessage(result);\n      } else {\n        const exposeObjectStructure = Object.fromEntries(\n          Object.entries(exposeObject).map(([key, value]) => [\n            key,\n            typeof value,\n          ])\n        );\n        throw new Error(\n          `Invalid ${MessageTypeEnum.RUN} message ${JSON.stringify(\n            data,\n            null,\n            2\n          )}. Expose object structure: ${JSON.stringify(\n            exposeObjectStructure,\n            null,\n            2\n          )}`\n        );\n      }\n    }\n  );\n}\n\nexport interface ProgressStatus {\n  current: number;\n  buffer: number;\n  total: number;\n}\n\n/**\n * Pooled executor for managing work across multiple processors.\n */\nexport class PooledExecutor {\n  private idleProcessors: PooledExecutor.Processor[] = [];\n\n  private pendingWorkQueue: PooledExecutor.QueuedWork<any, any>[] = [];\n\n  private runningWorkQueue: PooledExecutor.QueuedWorkInProgress<any, any>[] =\n    [];\n\n  private isStartWorkQueued = false;\n\n  public constructor(\n    private readonly processorGenerator: () => PooledExecutor.Processor,\n    processorCount: number,\n    private readonly isDebugging = false\n  ) {\n    range(processorCount).forEach(() =>\n      this.idleProcessors.push(processorGenerator())\n    );\n  }\n\n  private hasWork() {\n    return this.pendingWorkQueue.length > 0;\n  }\n\n  private hasIdleProcessors() {\n    return this.idleProcessors.length > 0;\n  }\n\n  private queueStartWork() {\n    if (this.isStartWorkQueued) {\n      return;\n    }\n\n    setTimeout(() => this.startWork(), 0);\n    this.isStartWorkQueued = true;\n  }\n\n  private startWork() {\n    this.debug(\n      'startWork',\n      this.pendingWorkQueue.length,\n      this.idleProcessors.length\n    );\n\n    this.isStartWorkQueued = false;\n    range(\n      Math.min(this.pendingWorkQueue.length, this.idleProcessors.length)\n    ).forEach(() => {\n      if (!this.hasWork()) {\n        return;\n      }\n\n      if (!this.hasIdleProcessors()) {\n        return;\n      }\n\n      const queuedWork = this.dequeueFirst()!;\n      const processor = this.idleProcessors.pop()!;\n\n      this.onWorkStarted(queuedWork, processor);\n\n      // Execute the work.\n      this.debug('Starting work', queuedWork.id, queuedWork.work.functionName);\n      processor\n        .execute(queuedWork.work, queuedWork.onStatus)\n        .then((data) => {\n          this.debug(\n            'Work result',\n            queuedWork.id,\n            queuedWork.work.functionName\n          );\n          return queuedWork.onData(data);\n        })\n        .catch((error) => {\n          this.debug('Work error:', error, queuedWork.work.functionName);\n          queuedWork.onError(error);\n        })\n        // Restore the processor.\n        .finally(() => {\n          this.debug(\n            'Work finished',\n            queuedWork.id,\n            queuedWork.work.functionName\n          );\n          this.stop(queuedWork.id);\n          // Try to do more work.\n          this.queueStartWork();\n        });\n    });\n  }\n\n  private debug(...arr: any[]) {\n    if (this.isDebugging) {\n      console.debug(...arr);\n    }\n  }\n\n  private onWorkStarted(\n    queuedWork: PooledExecutor.QueuedWork<any, any>,\n    processor: PooledExecutor.Processor\n  ) {\n    this.debug('onWorkStarted', queuedWork.id, queuedWork.work.functionName);\n    this.runningWorkQueue.push({\n      queuedWork,\n      processor,\n    });\n  }\n\n  /**\n   * Stop work. If it is pending, then it will be removed from the queue. If it is processing, it will be removed and\n   * the current process will be stopped.\n   * @param id\n   * @param beforeProcessorRecycle Execute this before recycling the processing back into the idle processor queue.\n   * @private\n   */\n  public stop(\n    id: string,\n    beforeProcessorRecycle: PooledExecutor.QueuedWorkInProgressCallback = () =>\n      undefined\n  ) {\n    this.debug('stop', id);\n    this.dequeue(id);\n\n    const workInProgress = this.dequeueWorkInProgress(id);\n    if (workInProgress) {\n      this.debug('Stopping processor');\n      workInProgress.processor.stop();\n      beforeProcessorRecycle(workInProgress);\n      this.debug('Recycling processor');\n      this.idleProcessors.push(workInProgress.processor);\n    }\n  }\n\n  public enqueue<Return, Status>(\n    work: PooledExecutor.Work<Return>\n  ): PooledExecutor.WorkHandler<Return, Status> {\n    const status = new Subject<Status>();\n    const dedupeStatus = new DeDuplicateCaller((message: any) =>\n      status.next(message)\n    );\n    const id = `${\n      this.pendingWorkQueue.length\n    }_${new Date().getTime()}_${Math.floor(Math.random() * 10000)}`;\n    const stop = () => {\n      this.debug('workHandler stop', id);\n      this.stop(id);\n    };\n\n    this.debug('enqueue', id, work.functionName);\n\n    const data = new Promise<Return>((onData, onError) => {\n      this.pendingWorkQueue.push({\n        id,\n        work,\n        stop,\n        onData,\n        onError,\n        onStatus: (message) => dedupeStatus.maybeCallWith(message),\n      });\n      this.debug(\n        'pendingWork push',\n        id,\n        work.functionName,\n        this.pendingWorkQueue.length\n      );\n    });\n\n    this.queueStartWork();\n\n    return {\n      id,\n      data,\n      status,\n      stop,\n    };\n  }\n\n  public dequeueFirst() {\n    this.debug('dequeueFirst');\n    const firstItem = this.pendingWorkQueue.slice(0, 1).pop();\n    if (firstItem) {\n      return this.dequeue(firstItem.id);\n    }\n\n    return undefined;\n  }\n\n  public dequeue(id: string) {\n    this.debug('dequeue', id);\n    const itemIndex = this.pendingWorkQueue.findIndex((item) => item.id === id);\n    if (itemIndex > -1) {\n      return this.pendingWorkQueue.splice(itemIndex, 1).pop();\n    }\n    return undefined;\n  }\n\n  private dequeueWorkInProgress(id: string) {\n    this.debug('dequeueWorkInProgress', id);\n    const index = this.runningWorkQueue.findIndex(\n      (item) => item.queuedWork.id === id\n    );\n    if (index > -1) {\n      return this.runningWorkQueue.splice(index, 1).pop();\n    }\n    return undefined;\n  }\n\n  public stopAll() {\n    this.pendingWorkQueue.forEach((item) => item.stop());\n    this.runningWorkQueue.forEach((item) => item.queuedWork.stop());\n  }\n}\n\nexport namespace PooledExecutor {\n  export interface Work<Return> {\n    functionName: string;\n    function: {\n      (...args: any[]): Return;\n      name: string;\n    };\n    args: any[];\n  }\n\n  export interface QueuedWork<Return, Status> {\n    id: string;\n    work: Work<Return>;\n    stop: () => void;\n    onData: (data: Return) => void;\n    onError: (error: any) => void;\n    onStatus: (status: Status) => void;\n  }\n\n  export interface QueuedWorkInProgress<Return, Status> {\n    queuedWork: PooledExecutor.QueuedWork<Return, Status>;\n    processor: PooledExecutor.Processor;\n  }\n\n  export type QueuedWorkInProgressCallback = (\n    workInProgress: QueuedWorkInProgress<any, any>\n  ) => void;\n\n  export interface WorkHandler<Return, Status> {\n    id: string;\n    data: Promise<Return>;\n    status: Subject<Status>;\n    stop: () => void;\n  }\n\n  export interface Processor {\n    execute<Return, Status>(\n      work: Work<Return>,\n      onStatus: (status: Status) => void\n    ): Promise<Return>;\n    stop(): void;\n  }\n\n  export class WebWorkerProcessor implements Processor {\n    private worker?: Worker;\n\n    public constructor(private readonly workerGenerator: () => Worker) {}\n\n    protected getWorker(): Worker {\n      if (!this.worker) {\n        this.worker = this.workerGenerator();\n      }\n\n      return this.worker;\n    }\n\n    public execute<Return, Status>(\n      work: Work<Return>,\n      onStatus: (status: Status) => void\n    ): Promise<Return> {\n      const worker = this.getWorker();\n\n      const result = new Promise<Return>((res, rej) => {\n        worker.onmessage = ({ data }) => {\n          if (isResultMessage(data)) {\n            res(data.data);\n          } else if (isStatusMessage(data)) {\n            onStatus(data.data.data);\n          }\n        };\n        worker.onerror = rej;\n        worker.onmessageerror = rej;\n      }).finally(() => {\n        worker.onmessage = () => undefined;\n        worker.onerror = () => undefined;\n        worker.onmessageerror = () => undefined;\n      });\n\n      worker.postMessage(newRunMessage(work.functionName, work.args));\n\n      return result;\n    }\n\n    public stop(): void {\n      this.worker?.terminate();\n      this.worker = undefined;\n    }\n  }\n\n  export class LocalProcessor implements Processor {\n    public async execute<Return, Status>(\n      work: Work<Return>,\n      onStatus: (status: Status) => void\n    ): Promise<Return> {\n      const dispatchStatus = (status: any) => {\n        onStatus(status.detail.data);\n      };\n      self.addEventListener(PROGRESS_STATUS_EVENT, dispatchStatus);\n\n      const result = await work.function(...work.args);\n\n      self.removeEventListener(PROGRESS_STATUS_EVENT, dispatchStatus);\n\n      return result;\n    }\n\n    public stop(): void {\n      // Empty because this cannot be supported on single threads.\n      // console.warn(\n      //   `${LocalProcessor.name}.${this.stop.name}() is not supported.`\n      // );\n    }\n  }\n}\n\ntype GenericFunction = (...args: any[]) => any;\ntype ObjectOfGenericFunctions = { [key: string | symbol]: GenericFunction };\n\nexport type PooledWorkerClientFunctionsType<\n  T extends ObjectOfGenericFunctions\n> = {\n  // We take just the method key and Promisify them,\n  // We have to use T[P] & Function because the compiler will not realize T[P] will always be a function\n  [P in JustMethodKeys<T>]: (\n    ...a: ArgumentTypes<T[P]>\n  ) => PooledExecutor.WorkHandler<ReturnType<T[P]>, ProgressStatus>;\n};\n\n/**\n * Takes an object of functions and wraps the functions in a pooled executor.\n * @param executor\n * @param sourceObject\n */\nexport function pooledFunctions<T extends ObjectOfGenericFunctions>(\n  executor: PooledExecutor,\n  sourceObject: T\n): PooledWorkerClientFunctionsType<T> {\n  return new Proxy(sourceObject, {\n    get(target: any, prop: string | symbol): any {\n      return (...args: any[]) => {\n        return executor.enqueue({\n          args,\n          functionName: prop.toString(),\n          function: (sourceObject as any)[prop],\n        });\n      };\n    },\n  });\n}\n","/*\nimport.meta use ES6 to resolve URLs. Jest doesn't handle this well, so we place the URL in its own file and have\njest use a mock (located in __mocks__) and load the mock globally in setup-jest.ts. This entirely avoids the use\nof this file during unit testing.\n */\nexport const solverCalculateWorkerFactory = () =>\n  new Worker(new URL('./solver-calculate.worker', import.meta.url));\n","/*\nimport.meta use ES6 to resolve URLs. Jest doesn't handle this well, so we place the URL in its own file and have\njest use a mock (located in __mocks__) and load the mock globally in setup-jest.ts. This entirely avoids the use\nof this file during unit testing.\n */\nexport const solverCommonWorkerFactory = () =>\n  new Worker(new URL('./solver-common.worker', import.meta.url));\n","import {\n  CalculateEquationResult,\n  commonWorkerFunctions,\n  MugginsSolverCalculateConfig,\n  MugginsSolverConfig,\n} from './solver-common';\nimport {\n  emitProgressStatusRoot,\n  PooledExecutor,\n  pooledFunctions,\n  PooledWorkerClientFunctionsType,\n  ProgressStatus,\n} from './worker-utils';\nimport { solverCalculateWorkerFactory } from './solver-calculate-worker-factory';\nimport { solverCommonWorkerFactory } from './solver-common-worker-factory';\nimport { chunk } from 'lodash';\nimport { Subject } from 'rxjs';\n\nconst localProcessorGenerator = () => new PooledExecutor.LocalProcessor();\n\nconst calculateProcessorGenerator = () =>\n  new PooledExecutor.WebWorkerProcessor(solverCalculateWorkerFactory);\n\nconst commonsProcessorGenerator = () =>\n  new PooledExecutor.WebWorkerProcessor(solverCommonWorkerFactory);\n\nfunction getProcessorGenerator(\n  solverConfig: MugginsSolverConfig,\n  useCommons: boolean\n): () => PooledExecutor.Processor {\n  if (!solverConfig.useWorker) {\n    return localProcessorGenerator;\n  }\n\n  if (useCommons) {\n    return commonsProcessorGenerator;\n  }\n\n  return calculateProcessorGenerator;\n}\n\n/**\n * Main solver that can use web workers to distribute the load of calculating solutions.\n */\nexport class MugginsSolver {\n  private readonly pooledExecutor;\n\n  private readonly pooledCommonWorkerFunctions;\n\n  private readonly arraySplitGroupSize: number;\n\n  private readonly currentStatus: ProgressStatus = {\n    current: 0,\n    buffer: 0,\n    total: 100,\n  };\n\n  public readonly status = new Subject<ProgressStatus>();\n\n  constructor(\n    private readonly solverConfig: MugginsSolverConfig,\n    private readonly shouldDebug = false\n  ) {\n    this.pooledExecutor = new PooledExecutor(\n      getProcessorGenerator(solverConfig, true),\n      solverConfig.useWorker ? solverConfig.workerCount : 1\n    );\n\n    this.pooledCommonWorkerFunctions = pooledFunctions(\n      this.pooledExecutor,\n      commonWorkerFunctions\n    ) as PooledWorkerClientFunctionsType<typeof commonWorkerFunctions>;\n\n    this.arraySplitGroupSize = this.solverConfig.workerCount * 2;\n  }\n\n  private debug(...args: any[]) {\n    if (this.shouldDebug) {\n      console.debug(...args);\n    }\n  }\n\n  private incrementBuffer(count: number) {\n    this.currentStatus.buffer += count;\n    this.status.next({\n      ...this.currentStatus,\n    });\n  }\n\n  private incrementProgress(count: number) {\n    this.currentStatus.current += count;\n    this.status.next({\n      ...this.currentStatus,\n    });\n  }\n\n  private monitorProgressIncrementor<T>(target: T, increment: number): T {\n    if (Array.isArray(target)) {\n      if (target[0] instanceof Promise) {\n        return target.map((item) =>\n          this.monitorProgressIncrementor(item, increment)\n        ) as any as T;\n      } else {\n        this.incrementProgress(increment * target.length);\n        return target;\n      }\n    } else if (target instanceof Promise) {\n      return target.finally(() =>\n        this.incrementProgress(increment)\n      ) as any as T;\n    } else {\n      this.incrementProgress(increment);\n      return target;\n    }\n  }\n\n  private monitorProgress<T>(\n    target: Promise<T>,\n    ratioOfTotal: number\n  ): Promise<T>;\n  private monitorProgress<T>(\n    target: Promise<T>[],\n    ratioOfTotal: number\n  ): Promise<T>[];\n  private monitorProgress<T>(target: T, ratioOfTotal: number): T;\n  private monitorProgress<T>(target: T, ratioOfTotal: number): T {\n    this.incrementBuffer(ratioOfTotal * 100);\n    if (Array.isArray(target)) {\n      return this.monitorProgressIncrementor(\n        target,\n        (1 / target.length) * ratioOfTotal * 100\n      );\n    } else {\n      return this.monitorProgressIncrementor(target, ratioOfTotal * 100);\n    }\n  }\n\n  public async calculate(\n    calculateConfig: MugginsSolverCalculateConfig\n  ): Promise<CalculateEquationResult[]> {\n    this.currentStatus.current = 0;\n\n    if (\n      calculateConfig.faces.length < 2 ||\n      calculateConfig.operations.length === 0 ||\n      calculateConfig.maxTotal < calculateConfig.minTotal\n    ) {\n      return [];\n    }\n\n    this.incrementProgress(0);\n\n    const fullStart = new Date().getTime();\n    let start = new Date().getTime();\n\n    // Run on the orchestration worker because everything is blocked anyway and doing so increases performance.\n    const [facePairingPermutations, operationPermutations] =\n      this.monitorProgress(\n        commonWorkerFunctions.getFaceAndOperationPermutations(calculateConfig),\n        0.05\n      );\n    this.debug(\n      'permutations',\n      new Date().getTime() - start,\n      'ms',\n      facePairingPermutations.length\n    );\n\n    start = new Date().getTime();\n    const sortedResults = await Promise.all(\n      this.monitorProgress(\n        chunk(facePairingPermutations, 100).map(\n          (arr) =>\n            this.pooledCommonWorkerFunctions.calculateFromFaceAndOperationPermutations(\n              calculateConfig,\n              arr,\n              operationPermutations\n            ).data\n        ),\n        0.8\n      )\n    );\n    this.debug(\n      'initial results',\n      new Date().getTime() - start,\n      'ms',\n      sortedResults.length\n    );\n\n    // Run on the orchestration worker because everything is blocked anyway and doing so increases performance.\n    start = new Date().getTime();\n    const finalResults = this.monitorProgress(\n      commonWorkerFunctions.mergeCalculateResultsArrays(sortedResults),\n      0.15\n    );\n    this.debug(\n      'merged results',\n      new Date().getTime() - start,\n      'ms',\n      finalResults.length\n    );\n    this.debug('full run', new Date().getTime() - fullStart, 'ms');\n\n    // Bring the progress up to 100.\n    this.incrementProgress(\n      this.currentStatus.total - this.currentStatus.current\n    );\n\n    return finalResults;\n  }\n\n  public stop() {\n    this.pooledExecutor.stopAll();\n  }\n\n  private static solver?: MugginsSolver;\n\n  public static stop() {\n    MugginsSolver.solver?.stop();\n    MugginsSolver.solver?.status.unsubscribe();\n  }\n\n  public static async calculate(\n    solverConfig: MugginsSolverConfig,\n    calculateConfig: MugginsSolverCalculateConfig\n  ): Promise<CalculateEquationResult[]> {\n    if (!!MugginsSolver.solver) {\n      throw new Error(\n        'Processor is already running. Stop it before trying again.'\n      );\n    }\n\n    const solver = new MugginsSolver(solverConfig);\n    solver.status.subscribe(emitProgressStatusRoot);\n    MugginsSolver.solver = new MugginsSolver(solverConfig);\n\n    const result = await solver.calculate(calculateConfig);\n    MugginsSolver.solver = undefined;\n    return result;\n  }\n}\n\nexport const calculateWorkerFunctions = {\n  calculate: MugginsSolver.calculate,\n};\n\n/**\n * Wraps MugginsSolver in a webworker. This ensures all the data serialize/deserialize and merging is done on a\n * separate worker. Thus keeping our UI responsive.\n */\nexport class MugginsSolverOrchestrator {\n  private readonly pooledCalculateFunctions;\n\n  public constructor(public readonly solverConfig: MugginsSolverConfig) {\n    this.pooledCalculateFunctions = pooledFunctions(\n      new PooledExecutor(getProcessorGenerator(solverConfig, false), 1),\n      calculateWorkerFunctions\n    );\n  }\n\n  public calculate(calculateConfig: MugginsSolverCalculateConfig) {\n    return this.pooledCalculateFunctions.calculate(\n      this.solverConfig,\n      calculateConfig\n    ) as any as PooledExecutor.WorkHandler<\n      CalculateEquationResult[],\n      ProgressStatus\n    >;\n  }\n}\n","import { calculateWorkerFunctions } from './solver';\nimport { expose } from './worker-utils';\n\nexpose(calculateWorkerFunctions);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [47], () => (__webpack_require__(265)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + {\"47\":\"a77b4e54f0d57a94\",\"232\":\"0c000d62613e8b0f\",\"265\":\"7d57d658350d0767\"}[chunkId] + \".js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var policy;\n__webpack_require__.tt = () => {\n\t// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.\n\tif (policy === undefined) {\n\t\tpolicy = {\n\t\t\tcreateScriptURL: (url) => (url)\n\t\t};\n\t\tif (typeof trustedTypes !== \"undefined\" && trustedTypes.createPolicy) {\n\t\t\tpolicy = trustedTypes.createPolicy(\"angular#bundler\", policy);\n\t\t}\n\t}\n\treturn policy;\n};","__webpack_require__.tu = (url) => (__webpack_require__.tt().createScriptURL(url));","__webpack_require__.p = \"\";","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t265: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.tu(__webpack_require__.p + __webpack_require__.u(chunkId)));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkapp\"] = self[\"webpackChunkapp\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(47).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"sourceRoot":"webpack:///","file":"265.7d57d658350d0767.js"}